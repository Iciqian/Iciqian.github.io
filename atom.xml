<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Iciqian的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-08T01:15:57.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Iciqian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2017/05/08/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/05/08/DNS解析过程/</id>
    <published>2017-05-08T01:15:57.000Z</published>
    <updated>2017-05-08T01:15:57.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS中this对象指向总结</title>
    <link href="http://yoursite.com/2017/05/08/this%E7%9A%84%E6%8C%87%E5%90%91%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/05/08/this的指向详解/</id>
    <published>2017-05-08T01:14:56.000Z</published>
    <updated>2017-05-08T04:47:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>在js中，每个函数在被调用时，会产生两个变量，this和arguments。这意味着，只有在函数调用之时，this的指向才能确定。</p>
<p>this在运行时是根据执行环境绑定的，主要分为以下六种情况：<br>当包含this的函数：<br>1.作为普通的全局函数调用：在全局函数中，this指向window。<br>2.作为对象的方法调用：在函数被作为某个对象的方法调用时，this指向那个对象。<br>3.作为构造函数调用：当函数为构造函数，此时this指向实例出来的对象。<br>4.被apply,bind，call等改变执行环境时，this指向其他对象。<br>5.是匿名函数，this永远指向window（在不改变执行环境的情况下）。<br>6.其他情况。</p>
<p>注意：无论那种情况，this的指向都遵循着根据执行环境绑定的规律。<br>下面进行详细说明：</p>
<h2 id="一、作为普通全局函数调用"><a href="#一、作为普通全局函数调用" class="headerlink" title="一、作为普通全局函数调用"></a>一、作为普通全局函数调用</h2><p>看一个栗子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var name=<span class="string">'w'</span>;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">a</span></span>()&#123;</div><div class="line">	console.log(this.name);</div><div class="line">&#125;;</div><div class="line">a();//<span class="string">'w'</span></div></pre></td></tr></table></figure></p>
<p>此时，函数a作为普通的全局函数被window调用，这种调用方法最常见，在这里，函数a中this指向window。<br><a id="more"></a></p>
<h2 id="二、作为对象的方法调用"><a href="#二、作为对象的方法调用" class="headerlink" title="二、作为对象的方法调用"></a>二、作为对象的方法调用</h2><p>再看一个栗子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var name=<span class="string">'w'</span>;</div><div class="line">var b = &#123;</div><div class="line">	name:<span class="string">'b'</span>,</div><div class="line">	getName:<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> this.name;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">console.log(b.getName());//<span class="string">'b'</span></div></pre></td></tr></table></figure></p>
<p>此时，函数getName()作为b对象的方法调用，this指向b。</p>
<h2 id="三、作为构造函数调用"><a href="#三、作为构造函数调用" class="headerlink" title="三、作为构造函数调用"></a>三、作为构造函数调用</h2><p>栗子again。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var name=<span class="string">'w'</span>;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">c</span></span>()&#123;</div><div class="line">	this.name=<span class="string">'c'</span>;</div><div class="line">	this.getName=<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">		console.log(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">var cc = new c();</div><div class="line">cc.getName();//<span class="string">'c'</span></div></pre></td></tr></table></figure></p>
<p>这里的函数c是一个构造函数，cc是c类型的一个实例对象，函数c中的this指向cc,所以cc.name=’c’，所以this.name=’c’。</p>
<h2 id="四、被apply-bind，call等改变执行环境"><a href="#四、被apply-bind，call等改变执行环境" class="headerlink" title="四、被apply,bind，call等改变执行环境"></a>四、被apply,bind，call等改变执行环境</h2><p>由于this与执行环境绑定，所以当执行环境改变，this的指向也会改变。<br>比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var name=<span class="string">'w'</span>;</div><div class="line">var d = &#123;</div><div class="line">	name:<span class="string">'d'</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">df</span></span>()&#123;</div><div class="line">	console.log(this.name);</div><div class="line">&#125;;</div><div class="line">df();//<span class="string">'w'</span></div><div class="line">df.call(d);//<span class="string">'d'</span></div></pre></td></tr></table></figure></p>
<p>当df作为全局函数在全局作用域中调用时，this指向window。<br>但当df的执行环境通过call改变，df中的this指向也随之改变，指向d。<br>除了call，使用apply,bind等改变执行环境,效果相同。</p>
<h2 id="五、匿名函数的this"><a href="#五、匿名函数的this" class="headerlink" title="五、匿名函数的this"></a>五、匿名函数的this</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var name=<span class="string">'w'</span>;</div><div class="line">var e = &#123;</div><div class="line">	name:<span class="string">'e'</span>,</div><div class="line">	getName:<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">			<span class="built_in">return</span> this.name;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">console.log(e.getName()());//<span class="string">'w'</span></div></pre></td></tr></table></figure>
<p>首先，前面说过，每个函数被调用时，都会自动生成两个变量：this和arguments。而内部函数被调用时，在搜索这两个变量时，只会搜索到活动对象为止，而永远不会访问到外部函数中的这两个变量。<br>其次，由于匿名函数具有全局性，在不改变执行环境情况的下，匿名函数的this永远指向window。<br>所以，当匿名函数作为闭包出现，在调用它时，其中的this通常指向window。<br>在此例中，调用了e对象的getName()方法中的匿名函数，匿名函数作为闭包出现，所以这里的this指向window。<br>如果非要访问外部作用域中的this，需要将this保存在内部函数能够访问到的变量里。如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name=<span class="string">'w'</span>;</div><div class="line">var e = &#123;</div><div class="line">	name:<span class="string">'e'</span>,</div><div class="line">	getName:<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">		var that = this;</div><div class="line">		<span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">			<span class="built_in">return</span> that.name;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">console.log(e.getName()());//<span class="string">'e'</span></div></pre></td></tr></table></figure>
<h2 id="六、其他情况"><a href="#六、其他情况" class="headerlink" title="六、其他情况"></a>六、其他情况</h2><p>1.函数作为事件处理程序调用<br>DOM0级和DOM2级事件处理程序在元素的作用域中运行，this指向当前元素。<br>IE事件处理程序在全局作用域中运行，this指向window。<br>2.语法细微变化也可能意外的引起this值的改变。<br>如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var name=<span class="string">'w'</span>;</div><div class="line">var object=&#123;</div><div class="line">	name: <span class="string">'My Object'</span>;</div><div class="line">	getName: <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">		retuen this.name;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">object.getName();//<span class="string">'My Object'</span></div><div class="line">(object.getName = object.getName)();//<span class="string">'w'</span></div></pre></td></tr></table></figure>
<p>(object.getName = object.getName)();<br>相当于:<br>（function(){<br>    retuen this.name;<br>})();</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在js中，每个函数在被调用时，会产生两个变量，this和arguments。这意味着，只有在函数调用之时，this的指向才能确定。&lt;/p&gt;
&lt;p&gt;this在运行时是根据执行环境绑定的，主要分为以下六种情况：&lt;br&gt;当包含this的函数：&lt;br&gt;1.作为普通的全局函数调用：在全局函数中，this指向window。&lt;br&gt;2.作为对象的方法调用：在函数被作为某个对象的方法调用时，this指向那个对象。&lt;br&gt;3.作为构造函数调用：当函数为构造函数，此时this指向实例出来的对象。&lt;br&gt;4.被apply,bind，call等改变执行环境时，this指向其他对象。&lt;br&gt;5.是匿名函数，this永远指向window（在不改变执行环境的情况下）。&lt;br&gt;6.其他情况。&lt;/p&gt;
&lt;p&gt;注意：无论那种情况，this的指向都遵循着根据执行环境绑定的规律。&lt;br&gt;下面进行详细说明：&lt;/p&gt;
&lt;h2 id=&quot;一、作为普通全局函数调用&quot;&gt;&lt;a href=&quot;#一、作为普通全局函数调用&quot; class=&quot;headerlink&quot; title=&quot;一、作为普通全局函数调用&quot;&gt;&lt;/a&gt;一、作为普通全局函数调用&lt;/h2&gt;&lt;p&gt;看一个栗子。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var name=&lt;span class=&quot;string&quot;&gt;&#39;w&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	console.log(this.name);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a();//&lt;span class=&quot;string&quot;&gt;&#39;w&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此时，函数a作为普通的全局函数被window调用，这种调用方法最常见，在这里，函数a中this指向window。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript学习" scheme="http://yoursite.com/tags/JavaScript%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JS闭包及应用</title>
    <link href="http://yoursite.com/2017/02/28/js%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2017/02/28/js闭包/</id>
    <published>2017-02-28T13:11:08.000Z</published>
    <updated>2017-05-08T04:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>定义：闭包是有权访问另一函数作用域的变量的函数。<br>常见创建闭包的方式：在一个函数内部创建另一个函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">str</span>)</span>&#123;</div><div class="line"> <span class="keyword">var</span> hello = <span class="string">"hello"</span>;</div><div class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(hello+str);</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="理解执行环境和作用域链"><a href="#理解执行环境和作用域链" class="headerlink" title="理解执行环境和作用域链"></a>理解执行环境和作用域链</h2><h3 id="执行环境（execution-context）"><a href="#执行环境（execution-context）" class="headerlink" title="执行环境（execution context）"></a>执行环境（execution context）</h3><p>1.<strong>执行环境</strong>：定义了变量或函数有权访问的其他数据。<br>2.<strong>变量对象</strong>：每个执行环境都有一个与之关联的变量对象（variable object）,环境中定义的所有变量和函数都保存在这个对象里。<br>3.某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。<br>4.<strong>全局执行环境</strong>:全局执行环境是最外围的一个执行环境，根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是window对象。全局执行环境直到应用程序退出才会被销毁。<br>5.<strong>每个函数都有自己的执行环境</strong>：当执行流进入到一个函数时，函数的环境就会被推入一个<strong>环境栈</strong>中，在函数执行之后，栈将环境弹出，把控制权返回给之前的执行环境。</p>
<h3 id="作用域链（scope-chain）"><a href="#作用域链（scope-chain）" class="headerlink" title="作用域链（scope chain）"></a>作用域链（scope chain）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>当代码在一个环境中执行时，会创建变量对象的一个作用域链。<br>作用域链保证对执行环境有权访问的所有变量和函数的有序访问。 </p>
</blockquote>
<p><strong>内容</strong>：作用域链的前端，始终是当前执行代码所在环境的变量对象。（如果环境是函数，则其活动对象为变量对象，活动对象最开始只包含一个变量，即arguments对象）。下一个变量对象来自外部环境，下一个变量对象来自于下一个包含环境。全局执行环境的变量对象始终都是作用域链中最后一个对象。</p>
<h4 id="作用域链的创建"><a href="#作用域链的创建" class="headerlink" title="作用域链的创建"></a>作用域链的创建</h4><p>当创建函数时:  [[scope]]属性保存包含全局变量的作用域链；<br>当调用函数时:  创建函数执行环境（execution context）;复制[[scope]]中对象构建执行环境的作用域链；活动对象（activation object）被创建并被推入执行环境作用域链前端;<br><strong>例</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">str</span>)</span>&#123;</div><div class="line"> <span class="keyword">var</span> hello = <span class="string">"hello"</span>;</div><div class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(hello+str);</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当创建sayHi()函数时:  [[scope]]属性保存包含全局变量对象（包含sayHi()函数）的作用域链。<br>当调用sayHi()函数时:  创建sayHi()函数的执行环境;复制[[scope]]中对象构建执行环境的作用域链；包含arguments,str和hello的活动对象被创建并被推入执行环境作用域链前端； </p>
<h4 id="作用域链的销毁"><a href="#作用域链的销毁" class="headerlink" title="作用域链的销毁"></a>作用域链的销毁</h4><p><strong>一般情况下</strong>：当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域。<br><strong>有闭包的情况</strong>：在外部函数,如sayHi()函数，执行完毕后，其包含arguments，str和hello的活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。使用将sayHi设置为null的方法解除对该函数的引用，即通知垃圾回收例程将其清除，匿名函数作用域被销毁。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">str</span>)</span>&#123;</div><div class="line"> <span class="keyword">var</span> hello = <span class="string">"hello"</span>;</div><div class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(hello+str);</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line">sayHi=<span class="literal">null</span>;</div></pre></td></tr></table></figure></p>
<h4 id="作用域链本质"><a href="#作用域链本质" class="headerlink" title="作用域链本质"></a>作用域链本质</h4><p>作用域链的本质是指向变量对象的<strong>指针列表</strong>，只<strong>引用</strong>，但不实际包含变量对象。</p>
<h4 id="分析调用sayHi（）函数过程中的作用域链"><a href="#分析调用sayHi（）函数过程中的作用域链" class="headerlink" title="分析调用sayHi（）函数过程中的作用域链"></a>分析调用sayHi（）函数过程中的作用域链</h4><p>闭包的作用域链包含它自己的作用域，包含函数的作用域和全局作用域。<br><img src="http://ww1.sinaimg.cn/mw1024/006bAzaMjw1falvb7a9u8j30mr0csdhd.jpg" alt=""></p>
<h2 id="关于闭包值得注意的问题"><a href="#关于闭包值得注意的问题" class="headerlink" title="关于闭包值得注意的问题"></a>关于闭包值得注意的问题</h2><h3 id="1-闭包只能取得包含函数中任何变量的最后一个值"><a href="#1-闭包只能取得包含函数中任何变量的最后一个值" class="headerlink" title="1.闭包只能取得包含函数中任何变量的最后一个值"></a>1.闭包只能取得包含函数中任何变量的最后一个值</h3><h3 id="2-闭包中的this对象通常指向window，除非通过apply-或call-改变函数执行环境。"><a href="#2-闭包中的this对象通常指向window，除非通过apply-或call-改变函数执行环境。" class="headerlink" title="2.闭包中的this对象通常指向window，除非通过apply()或call()改变函数执行环境。"></a>2.闭包中的this对象通常指向window，除非通过apply()或call()改变函数执行环境。</h3><p><strong>原因</strong>：每个函数在被调用时都会自动取得两个特殊的变量：<strong>this</strong>和<strong>arguments</strong>，因此当内部函数在搜索这两个变量时，只会搜索到其活动对象为止。<br><strong>访问外部作用域中this对象的方法</strong>：把外部作用域中的this对象保存在闭包能够访问的变量里。<br>修改前：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"><span class="keyword">var</span> object=&#123;</div><div class="line">	<span class="attr">name</span> : <span class="string">"My Object"</span>;</div><div class="line">	getNameFunc:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name;<span class="comment">//"The Window"</span></div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>修改后：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"><span class="keyword">var</span> object=&#123;</div><div class="line">	<span class="attr">name</span> : <span class="string">"My Object"</span>;</div><div class="line">	getNameFunc:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> that.name;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">alert(object.getNameFunc()())；<span class="comment">//"My Object"</span></div></pre></td></tr></table></figure></p>
<p><strong>访问外部作用域中arguments对象的方法</strong>：同样需要把该对象保存在闭包能够访问的变量里。<br><strong>另外，关于this对象</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"><span class="keyword">var</span> object=&#123;</div><div class="line">	<span class="attr">name</span> : <span class="string">"My Object"</span>;</div><div class="line">	getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">(object.getName=object.getName)()；<span class="comment">//"My Object"</span></div></pre></td></tr></table></figure></p>
<p>上例中先执行赋值语句，在调用赋值后的结果，因为此赋值表达式的值是<strong>函数本身</strong>，所以this的值不能维持。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="1-闭包会比其他函数占用更多内存。"><a href="#1-闭包会比其他函数占用更多内存。" class="headerlink" title="1.闭包会比其他函数占用更多内存。"></a>1.闭包会比其他函数占用更多内存。</h3><h3 id="2-当函数返回了一个闭包，这个函数的作用域将会在内存中保存至闭包不存在为止。"><a href="#2-当函数返回了一个闭包，这个函数的作用域将会在内存中保存至闭包不存在为止。" class="headerlink" title="2.当函数返回了一个闭包，这个函数的作用域将会在内存中保存至闭包不存在为止。"></a>2.当函数返回了一个闭包，这个函数的作用域将会在内存中保存至闭包不存在为止。</h3><p>解决：将外部函数设置为null。  </p>
<h3 id="3-如果闭包的作用域链中保存着HTML元素，意味着该元素将无法被销毁。"><a href="#3-如果闭包的作用域链中保存着HTML元素，意味着该元素将无法被销毁。" class="headerlink" title="3.如果闭包的作用域链中保存着HTML元素，意味着该元素将无法被销毁。"></a>3.如果闭包的作用域链中保存着HTML元素，意味着该元素将无法被销毁。</h3><p>解决：将HTML元素保存在外部作用域中，并在不需要时将保存HTML元素的变量设置为null。</p>
<h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><h3 id="闭包模仿块级作用域"><a href="#闭包模仿块级作用域" class="headerlink" title="闭包模仿块级作用域"></a>闭包模仿块级作用域</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><strong>创建并立即调用</strong>一个函数;<br>修改前：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>)</span></div><div class="line">	<span class="title">for</span>(<span class="params">var i=<span class="number">0</span>;i&lt;count;i++</span>)&#123;</div><div class="line">		alert(i);</div><div class="line">	&#125;</div><div class="line">	alert(i)；<span class="comment">//计数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里首先创建了一个outputNumbers（）函数，在函数内有一个for循环，由于JavaScript没有块级作用域，所以即使在循环外也可以访问循环内的变量i。</p>
</blockquote>
<p>修改后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>)</span></div><div class="line">	(<span class="params">function(</span>)&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</div><div class="line">			alert(i);</div><div class="line">		&#125;</div><div class="line">	&#125;)();</div><div class="line">	alert(i)<span class="comment">//导致一个错误！</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>现在在for循环外创建了一个私有作用域，并产生了一个闭包，由于在匿名函数中定义的任何变量都会在执行结束后销毁，因此变量i只能在循环中使用。</p>
</blockquote>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>经常<strong>在全局作用域中被用在函数外部</strong>，限制向全局作用域中添加过多变量和函数。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>既可以执行其中的代码，又不会在内存中留下对该函数的引用；<br>函数内部的所有变量都会被立即销毁（除非将某些变量赋值给了外部作用域）；<br>通过创建私有作用域，每个开发人员既可以使用自己的变量，又不并担心搞乱全局作用域；<br>减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁作用域链了；</p>
<h3 id="闭包创建私有变量"><a href="#闭包创建私有变量" class="headerlink" title="闭包创建私有变量"></a>闭包创建私有变量</h3><p>任何在函数中定义的变量都可以认为是私有变量。<br>私有变量包括函数的参数、局部变量和在函数内部定义的其它函数。<br>访问私有变量和私有函数的公有方法被称为<strong>特权方法</strong>（privileged method）。</p>
<h4 id="方法一：在构造函数中定义特权方法"><a href="#方法一：在构造函数中定义特权方法" class="headerlink" title="方法一：在构造函数中定义特权方法"></a>方法一：在构造函数中定义特权方法</h4><p>在构造函数内部定义了所有私有变量和函数，然后创建能访问这些私有成员的特权方法。<br>利用私有和特权成员可以<strong>隐藏</strong>那些不应该被直接修改的数据。<br>例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">MyObject</span></span>()&#123;</div><div class="line">	var privateVariable = 10;</div><div class="line">	<span class="keyword">function</span> <span class="function"><span class="title">privarFunc</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> <span class="literal">false</span>;	</div><div class="line">	&#125;</div><div class="line">	this.publicMethod = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">		privateVariable++；</div><div class="line">		<span class="built_in">return</span> privarFunc();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造函数模式的缺点：每个实例都会创建同样一组新方法。静态私有变量来实现特权方法可以避免这个问题。</p>
<h4 id="方法二：静态私有变量"><a href="#方法二：静态私有变量" class="headerlink" title="方法二：静态私有变量"></a>方法二：静态私有变量</h4><p>这个模式创建一个私有作用域，并在其中封装一个构造函数及相应的方法。<br>例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">（<span class="keyword">function</span>（）&#123;</div><div class="line">	var privateVariable = 10;</div><div class="line">	<span class="keyword">function</span> <span class="function"><span class="title">privarFunc</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> <span class="literal">false</span>;	</div><div class="line">	&#125;</div><div class="line">	MyObject = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">	&#125;//全局变量</div><div class="line">	MyObject.prototype.publicMethod = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">		privateVariable++；</div><div class="line">		<span class="built_in">return</span> privarFunc();	</div><div class="line">	&#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>缺点：每个实例都没有自己的私有变量。</p>
<h4 id="方法三：模块模式（module-pattern）"><a href="#方法三：模块模式（module-pattern）" class="headerlink" title="方法三：模块模式（module pattern）"></a>方法三：模块模式（module pattern）</h4><p>为<strong>单例</strong>创建私有变量和特权方法。<br>模块模式使用一个<strong>返回对象的匿名函数</strong>，这个匿名函数内部首先定义了私有变量和函数，然后将一个对象字面量作为函数的值返回。<br>例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var singleton =<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">	var privateVariable = 10;</div><div class="line">	<span class="keyword">function</span> <span class="function"><span class="title">privarFunc</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> <span class="literal">false</span>;	</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">return</span>&#123;</div><div class="line">		publicProperty : <span class="literal">true</span>;</div><div class="line">		publicMethod :　<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">			privateVariable++；</div><div class="line">			<span class="built_in">return</span> privarFunc();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<h4 id="方法四：增强的模块模式"><a href="#方法四：增强的模块模式" class="headerlink" title="方法四：增强的模块模式"></a>方法四：增强的模块模式</h4><p>适合单例必须是<strong>某种类型的实例</strong>，同时还必须添加某些属性和（或）方法对其<strong>加以增强</strong>的情况。<br>创建一个匿名函数，定义私有变量和方法，创建一个对象实例，为实例添加特权方法，最后返回这个实例。<br>例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var singleton = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">	var privateVariable = 10;</div><div class="line">	<span class="keyword">function</span> <span class="function"><span class="title">privarFunc</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> <span class="literal">false</span>;	</div><div class="line">	&#125;</div><div class="line">    var object = new CustonType();</div><div class="line">	object.publicProperty = <span class="literal">true</span>;</div><div class="line">	object.publicMethod = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">		privateVariable++；</div><div class="line">		<span class="built_in">return</span> privarFunc();	</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">return</span> object; </div><div class="line">&#125;()；</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义：闭包是有权访问另一函数作用域的变量的函数。&lt;br&gt;常见创建闭包的方式：在一个函数内部创建另一个函数。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayHi&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;str&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; hello = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        alert(hello+str);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript学习" scheme="http://yoursite.com/tags/JavaScript%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>制作下拉菜单Tips&amp;相关知识点复习</title>
    <link href="http://yoursite.com/2017/02/28/%E5%88%B6%E4%BD%9C%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95Tips/"/>
    <id>http://yoursite.com/2017/02/28/制作下拉菜单Tips/</id>
    <published>2017-02-28T13:11:08.000Z</published>
    <updated>2017-05-08T03:40:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="制作多级菜单"><a href="#制作多级菜单" class="headerlink" title="制作多级菜单"></a>制作多级菜单</h2><p>在第一层<code>&lt;li&gt;</code>标签下添加<code>&lt;ul&gt;</code>标签，创建二级菜单，在第二层<code>&lt;li&gt;</code>标签下添加<code>&lt;ul&gt;</code>标签，创建三级菜单…以此类推。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">   &lt;ul class=<span class="string">"top_nav"</span>&gt;          </div><div class="line">	&lt;li&gt;&lt;a href=<span class="string">"#"</span>&gt;课程大厅&lt;/a&gt; &lt;!--一级菜单--&gt;</div><div class="line">		&lt;ul&gt;                  </div><div class="line">			&lt;li&gt;&lt;a href=<span class="string">"#"</span>&gt;前端课程&lt;/a&gt; &lt;!--二级菜单--&gt;</div><div class="line">				&lt;ul&gt;          </div><div class="line">					&lt;li&gt;&lt;a href=<span class="string">"#"</span>&gt;html&lt;/a&gt;&lt;/li&gt; &lt;!--三级菜单--&gt;</div><div class="line">					&lt;li&gt;&lt;a href=<span class="string">"#"</span>&gt;css&lt;/a&gt;&lt;/li&gt;</div><div class="line">					&lt;li&gt;&lt;a href=<span class="string">"#"</span>&gt;javascript&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;/ul&gt;</div><div class="line">			&lt;/li&gt;</div><div class="line">		&lt;/ul&gt;</div><div class="line">	&lt;/li&gt;</div><div class="line">	&lt;li&gt;&lt;a href=<span class="string">"#"</span>&gt;学习中心&lt;/a&gt;&lt;/li&gt;</div><div class="line">	&lt;li&gt;&lt;a href=<span class="string">"#"</span>&gt;关于我们&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>对所有li元素设置position：relative，对li元素下的子元素ul设置position：absolute，使下一级菜单相对于上一级菜单定位。<br><a id="more"></a></p>
<h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><p>鼠标停留在菜单上，以某种动画效果显示下一级菜单；鼠标离开，下一级菜单隐藏。</p>
<h3 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h3><blockquote>
<p>思路：<br>Step1:遍历所有<code>&lt;li&gt;</code>标签，为所有的li添加onmouseover和onmouseout事件；<br>Step2:如果此li下包含子元素ul（非孙辈），则把该子元素ul和指定属性的目标值作为参数传入move函数；<br>Step3:move函数：为传入的ul绑定定时器，设定速度（注意小数点），在指定属性现值不等于目标值的情况下，指定属性值为现值加速度，否则清除定时器。  为避免鼠标移动过快出现多个定时器，在move函数开头也需清除定时器；<br>Step4:获取html元素的属性值需要编写getStyle()函数； </p>
</blockquote>
<h3 id="jquery实现"><a href="#jquery实现" class="headerlink" title="jquery实现"></a>jquery实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(document).ready(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">$(<span class="string">'li'</span>).has(<span class="string">'ul'</span>).mouseover(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">$(this).children(<span class="string">'ul'</span>).css(<span class="string">'display'</span>,<span class="string">'block'</span>)&#125;).mouseout(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">$(this).children(<span class="string">'ul'</span>).css(<span class="string">'display'</span>,<span class="string">'none'</span>);</div><div class="line">&#125;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="CSS3实现"><a href="#CSS3实现" class="headerlink" title="CSS3实现"></a>CSS3实现</h3><blockquote>
<p>思路：使用transition属性实现;  </p>
</blockquote>
<h4 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h4><p><strong>Transition:</strong><br>用于在一定的时间内平滑的过渡，可以在鼠标点击，获取焦点，被点击或对元素任何改变中触发，并以圆滑的动画效果改变css属性的属性值。<br><strong>取值：</strong><br>&lt;’ transition-property ‘&gt;： 检索或设置对象中的参与过渡的属性<br>&lt;’ transition-duration ‘&gt;： 检索或设置对象过渡的持续时间<br>&lt;’ transition-timing-function ‘&gt;： 检索或设置对象中过渡的动画类型<br>&lt;’ transition-delay ‘&gt;： 检索或设置对象延迟过渡的时间<br><strong>eg:</strong><br>Transition-property: border-color, background-color, color<br>Transition-duration:.2s<br>Transition-timing-function:ease-in<br>Transition-delay:.1s<br>或<br>Transition:all,.2s,ease-in<br><em>设置transition属性后，需hover，focus等触发。</em><br><strong>兼容：</strong><br>IE10.0+, Firefox4.0-15.0(-moz-) 16.0+, Chrome4.0-25.0(-webkit-) 26+, Safari6.0(-webkit-) 6.1+, Opera15.0+</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;制作多级菜单&quot;&gt;&lt;a href=&quot;#制作多级菜单&quot; class=&quot;headerlink&quot; title=&quot;制作多级菜单&quot;&gt;&lt;/a&gt;制作多级菜单&lt;/h2&gt;&lt;p&gt;在第一层&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;标签下添加&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;标签，创建二级菜单，在第二层&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;标签下添加&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;标签，创建三级菜单…以此类推。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;   &amp;lt;ul class=&lt;span class=&quot;string&quot;&gt;&quot;top_nav&quot;&lt;/span&gt;&amp;gt;          &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;&amp;gt;课程大厅&amp;lt;/a&amp;gt; &amp;lt;!--一级菜单--&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;lt;ul&amp;gt;                  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;&amp;gt;前端课程&amp;lt;/a&amp;gt; &amp;lt;!--二级菜单--&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				&amp;lt;ul&amp;gt;          &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;&amp;gt;html&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;!--三级菜单--&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;&amp;gt;css&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;&amp;gt;javascript&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				&amp;lt;/ul&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;lt;/ul&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;&amp;gt;学习中心&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;&amp;gt;关于我们&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对所有li元素设置position：relative，对li元素下的子元素ul设置position：absolute，使下一级菜单相对于上一级菜单定位。&lt;br&gt;
    
    </summary>
    
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的程序设计——创建对象</title>
    <link href="http://yoursite.com/2017/02/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/28/面向对象的程序设计（1）/</id>
    <published>2017-02-28T13:11:08.000Z</published>
    <updated>2017-03-07T05:13:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>定义:hahahahhahahhahahhahahahahahhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh<br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义:hahahahhahahhahahhahahahahahhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面向对象的程序设计——继承</title>
    <link href="http://yoursite.com/2017/02/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2017/02/28/面向对象的程序设计（2）/</id>
    <published>2017-02-28T13:11:08.000Z</published>
    <updated>2016-12-04T14:07:40.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
