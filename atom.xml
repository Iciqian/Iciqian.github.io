<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Iciqian的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-15T09:29:03.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Iciqian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP的三次握手和四次挥手</title>
    <link href="http://yoursite.com/2017/05/12/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://yoursite.com/2017/05/12/TCP的三次握手和四次挥手/</id>
    <published>2017-05-12T14:49:17.000Z</published>
    <updated>2017-05-15T09:29:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、TCP协议简介"><a href="#一、TCP协议简介" class="headerlink" title="一、TCP协议简介"></a>一、TCP协议简介</h3><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，通过三次握手建立连接，通讯完成时要拆除连接。由于TCP是面向连接的，所以只能用于端到端的通讯。</p>
<h3 id="二、TCP协议头部的格式："><a href="#二、TCP协议头部的格式：" class="headerlink" title="二、TCP协议头部的格式："></a>二、TCP协议头部的格式：</h3><p><img src="http://wx2.sinaimg.cn/mw690/006bAzaMly1ffm1igm5v6j30an04o3yk.jpg" alt=""></p>
<h3 id="三、TCP连接建立："><a href="#三、TCP连接建立：" class="headerlink" title="三、TCP连接建立："></a>三、TCP连接建立：</h3><p>第一次握手：首先，客户端向服务端发送连接请求SYN报文。标志位SYN置为1，序号(随机)为j，即SYN=1 seq=j 。客户端进入SYN_SENT状态。</p>
<p>第二次握手：服务器接收到SYN报文后，发送SYN+ACK报文。将标志位的SYN和ACK都置为1，并将序号置为k，确认号置为j+1。即 SYN=1 ACK=1 seq=k ack=j+1 。服务器进入SYN_RECV状态。</p>
<p>第三次握手：客户端接收到SYN+ACK报文后，检查ACK与ack。检查无误，向服务器发送ACK报文，将标志位ACK置为1，确认号为k+1，即 ACK=1 ack=k+1。服务器接收到后，检查ACK与ack。检查无误，客户端和服务器进入ESTABLISHED状态，完成三次握手，建立TCP连接，开始传输数据。</p>
<p>简略版：<br>客户端：让我们建立连接吧！服务端！<br>服务端：好的客户端我收到了你发送的信息！让我们建立连接吧！<br>客户端：知道了服务端，我也能收到你发送的信息！<br>服务器得知客户端能接受到自己发送的信息，连接建立。<br><a id="more"></a></p>
<h5 id="为什么要进行三次握手？"><a href="#为什么要进行三次握手？" class="headerlink" title="为什么要进行三次握手？"></a>为什么要进行三次握手？</h5><p>1.建立稳定的连接，双方都能向对方发送报文，也能确认对方能收自己的报文。<br>2.防止服务端因已失效的连接请求报文段浪费资源。<br>当客户端发出了一个连接请求报文，然而该请求却在网络中某节点被阻塞住了，以至于延误到连接释放以后的某个时间才到达服务端。此时服务器会向客户端发送确认报文，如果只有两次握手，那么此时连接就建立了…服务器将长时间等待客户端发数据，却一直等不到，造成资源的极大浪费。如果是三次握手呢，由于客户端并不会回复服务器的确认报文，连接并不会建立，节约了资源。</p>
<h3 id="四、TCP连接中断"><a href="#四、TCP连接中断" class="headerlink" title="四、TCP连接中断"></a>四、TCP连接中断</h3><p>第一次挥手：客户端发起中断连接请求，发送FIN报文：将标志位FIN置为1，序号置为u。此时客户端进入FIN_WAIT_1状态，表示没有数据要传输给服务端了。</p>
<p>第二次挥手：服务端收到FIN报文后，发送ACK报文，表示同意关闭请求：标志位ACK置为1，确认序号为u+1。此时服务端进入CLOSE_WAIT状态，客户端接受到ACK报文后，进入FIN_WAIT_2状态。</p>
<p>第三次挥手：服务端再发送一个FIN报文，请求关闭连接：标志位FIN置为1，序号为w。服务端进入LAST_ACK状态，表示没有数据要传输给客户端了。</p>
<p>第四次挥手：客户端收到FIN报文后，发送一个ACK报文，确认序号为w+1，此时客户端进入TIME_WAIT状态。服务端收到ACK报文后，进入CLOSED状态。此时客户端会等待2MSL，如果没有收到回复，证明服务端已经关闭了连接，那么客户端也会关闭连接，进入CLOSED状态。至此，四次挥手完成，TCP连接断开。如果在TIME_WAIT状态中，客户端最后一次发送的ACK丢失了，它将重新发送。</p>
<p>简略版：<br>客户端：我要请求关闭连接！我没有数据要传输给你了！<br>服务端：好的我知道了！诶你等等，我看看还有没有数据没传输完！<br>服务端：关闭连接吧！客户端！<br>客户端：好的我知道了！<br>客户端等了2MLS后，并没有受到服务器的回复，得知服务端已经关闭了连接，于是自己也关闭了。</p>
<h5 id="为什么要进行四次挥手？"><a href="#为什么要进行四次挥手？" class="headerlink" title="为什么要进行四次挥手？"></a>为什么要进行四次挥手？</h5><p>因为TCP连接是全双工模式。当关闭连接时，一方收到另一方的FIN报文，仅仅表示另一方不再发送数据了，但是还可以接收数据，而自己也不一定将所有数据都发送给对方了。<br>表现就是，服务端接收到客户端发来的FIN报文时，不会立即发送FIN报文，而是会先回复一个ACK报文，并进入CLOSE_WAIT状态。这是因为服务端此时可能并没有传输完数据，只有当没有数据需要传输了，才会发送FIN报文给客户端，同意断开连接。而所以需要四次挥手。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、TCP协议简介&quot;&gt;&lt;a href=&quot;#一、TCP协议简介&quot; class=&quot;headerlink&quot; title=&quot;一、TCP协议简介&quot;&gt;&lt;/a&gt;一、TCP协议简介&lt;/h3&gt;&lt;p&gt;TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，通过三次握手建立连接，通讯完成时要拆除连接。由于TCP是面向连接的，所以只能用于端到端的通讯。&lt;/p&gt;
&lt;h3 id=&quot;二、TCP协议头部的格式：&quot;&gt;&lt;a href=&quot;#二、TCP协议头部的格式：&quot; class=&quot;headerlink&quot; title=&quot;二、TCP协议头部的格式：&quot;&gt;&lt;/a&gt;二、TCP协议头部的格式：&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://wx2.sinaimg.cn/mw690/006bAzaMly1ffm1igm5v6j30an04o3yk.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;三、TCP连接建立：&quot;&gt;&lt;a href=&quot;#三、TCP连接建立：&quot; class=&quot;headerlink&quot; title=&quot;三、TCP连接建立：&quot;&gt;&lt;/a&gt;三、TCP连接建立：&lt;/h3&gt;&lt;p&gt;第一次握手：首先，客户端向服务端发送连接请求SYN报文。标志位SYN置为1，序号(随机)为j，即SYN=1 seq=j 。客户端进入SYN_SENT状态。&lt;/p&gt;
&lt;p&gt;第二次握手：服务器接收到SYN报文后，发送SYN+ACK报文。将标志位的SYN和ACK都置为1，并将序号置为k，确认号置为j+1。即 SYN=1 ACK=1 seq=k ack=j+1 。服务器进入SYN_RECV状态。&lt;/p&gt;
&lt;p&gt;第三次握手：客户端接收到SYN+ACK报文后，检查ACK与ack。检查无误，向服务器发送ACK报文，将标志位ACK置为1，确认号为k+1，即 ACK=1 ack=k+1。服务器接收到后，检查ACK与ack。检查无误，客户端和服务器进入ESTABLISHED状态，完成三次握手，建立TCP连接，开始传输数据。&lt;/p&gt;
&lt;p&gt;简略版：&lt;br&gt;客户端：让我们建立连接吧！服务端！&lt;br&gt;服务端：好的客户端我收到了你发送的信息！让我们建立连接吧！&lt;br&gt;客户端：知道了服务端，我也能收到你发送的信息！&lt;br&gt;服务器得知客户端能接受到自己发送的信息，连接建立。&lt;br&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>关于获取元素尺寸和位置属性的总结</title>
    <link href="http://yoursite.com/2017/05/11/%E5%85%B3%E4%BA%8E%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%B0%BA%E5%AF%B8%E5%92%8C%E5%92%8C%E4%BD%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/05/11/关于获取元素尺寸和和位置属性的总结/</id>
    <published>2017-05-11T13:05:56.000Z</published>
    <updated>2017-05-11T14:55:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>正在写一个飞机大战的小游戏，编写过程中发现一个小问题：当获取隐藏元素尺寸时，offsetWidth与offsetHeight属性无效。研究一番，发现原来是由于这两个属性是元素通过css渲染到页面上时才计算的，而display:none的隐藏元素不参与渲染，因此无法获取尺寸。解决方法很简单，使用height:0px来隐藏元素即可。<br>趁此机会，总结一下几个易混淆的用于获取元素尺寸和位置的属性。</p>
<h3 id="偏移量（offset-dimension）"><a href="#偏移量（offset-dimension）" class="headerlink" title="偏移量（offset dimension）"></a>偏移量（offset dimension）</h3><p>偏移量包括元素在屏幕上占用的所有可见空间，包括所有内边距、滚动条和边框大小。只读。<br>offsetHeight:元素在垂直方向占用空间大小。包括元素内容区高度、上下内边距高度、（可见）水平滚动条高度和上下边框高度。<br>offsetWidth:元素在水平方向占用空间大小。包括元素区宽度、左右内边距宽度、（可见）垂直滚动条的宽度和左右边框的宽度。<br>offsetLeft:元素的左外边框距离定位父元素（保存在offsetParent属性中）的距离。<br>offsetTop：元素的上外边框距离定位元素（保存在offsetParent属性中）的距离。</p>
<p>offsetParent属性的值:<br>（规律适用范围：table和内嵌框架布局页面除外的简单css布局页面）<br>1.如果有已定位（position属性不为static）的父元素，offsetParent属性的值是经过定位的这个父元素。<br>2.如果没有已定位的父元素，且元素自身position属性不为fixed,offsetParent属性的值是body。<br>3.如果元素本身使用了fixed进行定位，offsetParent属性值为null,这是因为fixed是相对视口定位，无定位父元素（但在Firefox中返回body）。<br><a id="more"></a></p>
<h3 id="客户区大小（client-dimension）"><a href="#客户区大小（client-dimension）" class="headerlink" title="客户区大小（client dimension）"></a>客户区大小（client dimension）</h3><p>客户区大小指的是元素内容及其内边距所占用的空间大小，不包括滚动条。只读。<br>clientHeight:元素内容区高度加上下内边距的高度。<br>clientWidth:元素内容区宽度加左右内边距的宽度。<br>clinetLeft:元素左边框宽度。<br>clientTop:元素上边框高度。</p>
<p>确定浏览器视口/网页可视区域大小的方法：<br>运行在标准模式下的IE6+、Chrome、Opera、Firefox、Safari,以及运行在混杂模式下的Chorme和Safari:<br>document.documentElement.clientHeight:浏览器视口高度。<br>document.documentElement.clientWidth:浏览器视口宽度。<br>运行在混杂模式中的IE6+、Chrome、Safari、Firefox、Safari：<br>docuemnt.body.clientHeight:浏览器视口高度。<br>docuemnt.body.clientWidth:浏览器视口宽度。</p>
<p>兼容方法：检查document.compatMode属性，判断页面是否处于标准模式，标准模式使用document.documentELement,混杂模式或document.compatMode属性不存在则使用document.body。</p>
<h3 id="滚动大小（scroll-dimension"><a href="#滚动大小（scroll-dimension" class="headerlink" title="滚动大小（scroll dimension)"></a>滚动大小（scroll dimension)</h3><p>滚动大小指的是包含滚动内容的元素的大小,除了一些元素（如html元素）以外，另外一些元素都需要通过CSS的overflow属性进行设置才能滚动。<br>scrollHeight:在没有滚动条的情况下，元素内容的总高度。<br>scrollWidth:在没有滚动条的情况下，元素内容的总宽度。<br>scrollLeft:被隐藏在内容区域左侧的像素数，通过设置这个属性可以改变元素的滚动位置。<br>scrollTop:被隐藏在内容区域上方的像素数，通过设置这个属性可以改变元素的滚动位置。</p>
<p>确定文档总高度时，必须取得scrollWidth/clientWidth和scrollHeight/clientHeight中的最大值，才能保证在跨浏览器环境下得到精确结果。对于大多数浏览器，使用document.documentElement。对于运行在混杂模式下的IE，需要使用document.body代替document.documentElement。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正在写一个飞机大战的小游戏，编写过程中发现一个小问题：当获取隐藏元素尺寸时，offsetWidth与offsetHeight属性无效。研究一番，发现原来是由于这两个属性是元素通过css渲染到页面上时才计算的，而display:none的隐藏元素不参与渲染，因此无法获取尺寸。解决方法很简单，使用height:0px来隐藏元素即可。&lt;br&gt;趁此机会，总结一下几个易混淆的用于获取元素尺寸和位置的属性。&lt;/p&gt;
&lt;h3 id=&quot;偏移量（offset-dimension）&quot;&gt;&lt;a href=&quot;#偏移量（offset-dimension）&quot; class=&quot;headerlink&quot; title=&quot;偏移量（offset dimension）&quot;&gt;&lt;/a&gt;偏移量（offset dimension）&lt;/h3&gt;&lt;p&gt;偏移量包括元素在屏幕上占用的所有可见空间，包括所有内边距、滚动条和边框大小。只读。&lt;br&gt;offsetHeight:元素在垂直方向占用空间大小。包括元素内容区高度、上下内边距高度、（可见）水平滚动条高度和上下边框高度。&lt;br&gt;offsetWidth:元素在水平方向占用空间大小。包括元素区宽度、左右内边距宽度、（可见）垂直滚动条的宽度和左右边框的宽度。&lt;br&gt;offsetLeft:元素的左外边框距离定位父元素（保存在offsetParent属性中）的距离。&lt;br&gt;offsetTop：元素的上外边框距离定位元素（保存在offsetParent属性中）的距离。&lt;/p&gt;
&lt;p&gt;offsetParent属性的值:&lt;br&gt;（规律适用范围：table和内嵌框架布局页面除外的简单css布局页面）&lt;br&gt;1.如果有已定位（position属性不为static）的父元素，offsetParent属性的值是经过定位的这个父元素。&lt;br&gt;2.如果没有已定位的父元素，且元素自身position属性不为fixed,offsetParent属性的值是body。&lt;br&gt;3.如果元素本身使用了fixed进行定位，offsetParent属性值为null,这是因为fixed是相对视口定位，无定位父元素（但在Firefox中返回body）。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript学习" scheme="http://yoursite.com/tags/JavaScript%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>DNS解析过程简述</title>
    <link href="http://yoursite.com/2017/05/08/DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/05/08/DNS解析过程/</id>
    <published>2017-05-08T01:15:57.000Z</published>
    <updated>2017-05-15T09:31:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>从输入网址到网页呈现，第一步就是通过DNS该网址解析成IP地址。</p>
<p>1.首先，浏览器会查询缓存中是否有与该域名对应的IP地址，如果有，解析结束。<br>2.如果在浏览器缓存中查找不到，浏览器会查询操作系统缓存是否有与该域名对应的IP地址，如果有，解析结束。<br>3.如果在操作系统缓存中也查找不到，浏览器向本地DNS服务器发起解析请求，解析程序把待解析的域名放在DNS请求报文中，以UDP用户数据的方式发给本地DNS服务器，进行递归查询。<br>4.本地DNS服务器收到请求后，先查询本地缓存，如果查找到与该域名对应的IP地址，直接将查询结果返回。<br>5.如果本地DNS服务器中没有对应的记录，本地DNS服务器便会发起迭代查询，首先查询根域名服务器。<br>6.根域名服务器返回给本地DNS服务器包含下一级域名的DNS服务器的IP地址，本地DNS服务器根据这个IP地址访问下一级DNS服务器，再得到下一级域名的信息的DNS服务器地址。<br>7.按上述方法迭代查询。直到在含有目标域名的DNS服务器上找到相对应的IP地址。<br>8.本地DNS服务器缓存域名与IP地址的对应关系（缓存时间由TTL值控制），并将查询结果返回浏览器。<br>9.浏览器根据IP地址访问目标主机，并将域名与IP地址的对应关系保存在缓存中（缓存时间由TTL值控制）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从输入网址到网页呈现，第一步就是通过DNS该网址解析成IP地址。&lt;/p&gt;
&lt;p&gt;1.首先，浏览器会查询缓存中是否有与该域名对应的IP地址，如果有，解析结束。&lt;br&gt;2.如果在浏览器缓存中查找不到，浏览器会查询操作系统缓存是否有与该域名对应的IP地址，如果有，解析结束。&lt;br
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>JS中this对象指向总结</title>
    <link href="http://yoursite.com/2017/05/08/this%E7%9A%84%E6%8C%87%E5%90%91%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/05/08/this的指向详解/</id>
    <published>2017-05-08T01:14:56.000Z</published>
    <updated>2017-05-08T06:33:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>在js中，每个函数在被调用时，会产生两个变量，this和arguments。这意味着，只有在函数调用之时，this的指向才能确定。</p>
<p>this在运行时是根据执行环境绑定的，主要分为以下六种情况：<br>当包含this的函数：<br>1.作为普通的全局函数调用：在全局函数中，this指向window。<br>2.作为对象的方法调用：在函数被作为某个对象的方法调用时，this指向那个对象。<br>3.作为构造函数调用：当函数为构造函数，此时this指向实例出来的对象。<br>4.被apply,bind，call等改变执行环境时，this指向其他对象。<br>5.是匿名函数，this永远指向window（在不改变执行环境的情况下）。<br>6.其他情况。</p>
<p>注意：无论那种情况，this的指向都遵循着根据执行环境绑定的规律。<br>下面进行详细说明：</p>
<h2 id="一、作为普通全局函数调用"><a href="#一、作为普通全局函数调用" class="headerlink" title="一、作为普通全局函数调用"></a>一、作为普通全局函数调用</h2><p>看一个栗子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var name=<span class="string">'w'</span>;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">a</span></span>()&#123;</div><div class="line">	console.log(this.name);</div><div class="line">&#125;;</div><div class="line">a();//<span class="string">'w'</span></div></pre></td></tr></table></figure></p>
<p>此时，函数a作为普通的全局函数调用，形式为函数名加括号，这种调用方法最常见，在这里，函数a中this指向window。<br><a id="more"></a></p>
<h2 id="二、作为对象的方法调用"><a href="#二、作为对象的方法调用" class="headerlink" title="二、作为对象的方法调用"></a>二、作为对象的方法调用</h2><p>再看一个栗子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var name=<span class="string">'w'</span>;</div><div class="line">var b = &#123;</div><div class="line">	name:<span class="string">'b'</span>,</div><div class="line">	getName:<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> this.name;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">console.log(b.getName());//<span class="string">'b'</span></div></pre></td></tr></table></figure></p>
<p>此时，函数getName()作为b对象的方法调用，this指向b。</p>
<h2 id="三、作为构造函数调用"><a href="#三、作为构造函数调用" class="headerlink" title="三、作为构造函数调用"></a>三、作为构造函数调用</h2><p>栗子again。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var name=<span class="string">'w'</span>;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">c</span></span>()&#123;</div><div class="line">	this.name=<span class="string">'c'</span>;</div><div class="line">	this.getName=<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">		console.log(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">var cc = new c();</div><div class="line">cc.getName();//<span class="string">'c'</span></div></pre></td></tr></table></figure></p>
<p>这里的函数c是一个构造函数，cc是c类型的一个实例对象，函数c中的this指向cc,所以cc.name=’c’，所以this.name=’c’。</p>
<h2 id="四、被apply-bind，call等改变执行环境"><a href="#四、被apply-bind，call等改变执行环境" class="headerlink" title="四、被apply,bind，call等改变执行环境"></a>四、被apply,bind，call等改变执行环境</h2><p>由于this与执行环境绑定，所以当执行环境改变，this的指向也会改变。<br>比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var name=<span class="string">'w'</span>;</div><div class="line">var d = &#123;</div><div class="line">	name:<span class="string">'d'</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">df</span></span>()&#123;</div><div class="line">	console.log(this.name);</div><div class="line">&#125;;</div><div class="line">df();//<span class="string">'w'</span></div><div class="line">df.call(d);//<span class="string">'d'</span></div></pre></td></tr></table></figure></p>
<p>当df作为全局函数在全局作用域中调用时，this指向window。<br>但当df的执行环境通过call改变，df中的this指向也随之改变，指向d。<br>除了call，使用apply,bind等改变执行环境,效果相同。</p>
<h2 id="五、匿名函数的this"><a href="#五、匿名函数的this" class="headerlink" title="五、匿名函数的this"></a>五、匿名函数的this</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var name=<span class="string">'w'</span>;</div><div class="line">var e = &#123;</div><div class="line">	name:<span class="string">'e'</span>,</div><div class="line">	getName:<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">			<span class="built_in">return</span> this.name;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">console.log(e.getName()());//<span class="string">'w'</span></div></pre></td></tr></table></figure>
<p>首先，前面说过，每个函数被调用时，都会自动生成两个变量：this和arguments。而内部函数被调用时，在搜索这两个变量时，只会搜索到活动对象为止，而永远不会访问到外部函数中的这两个变量。<br>其次，由于匿名函数具有全局性，在不改变执行环境情况的下，匿名函数的this永远指向window。<br>所以，当匿名函数作为闭包出现，在调用它时，其中的this通常指向window。<br>在此例中，调用了e对象的getName()方法中的匿名函数，匿名函数作为闭包出现，所以这里的this指向window。<br>如果非要访问外部作用域中的this，需要将this保存在内部函数能够访问到的变量里。如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name=<span class="string">'w'</span>;</div><div class="line">var e = &#123;</div><div class="line">	name:<span class="string">'e'</span>,</div><div class="line">	getName:<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">		var that = this;</div><div class="line">		<span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">			<span class="built_in">return</span> that.name;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">console.log(e.getName()());//<span class="string">'e'</span></div></pre></td></tr></table></figure>
<h2 id="六、其他情况"><a href="#六、其他情况" class="headerlink" title="六、其他情况"></a>六、其他情况</h2><p>1.函数作为事件处理程序调用<br>DOM0级和DOM2级事件处理程序在元素的作用域中运行，this指向当前元素。<br>IE事件处理程序在全局作用域中运行，this指向window。<br>2.语法细微变化也可能意外的引起this值的改变。<br>如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var name=<span class="string">'w'</span>;</div><div class="line">var object=&#123;</div><div class="line">	name: <span class="string">'My Object'</span>;</div><div class="line">	getName: <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> this.name;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">object.getName();//<span class="string">'My Object'</span></div><div class="line">(object.getName = object.getName)();//<span class="string">'w'</span></div></pre></td></tr></table></figure>
<p>(object.getName = object.getName)();<br>相当于:<br>（function(){<br>    return this.name;<br>})();</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在js中，每个函数在被调用时，会产生两个变量，this和arguments。这意味着，只有在函数调用之时，this的指向才能确定。&lt;/p&gt;
&lt;p&gt;this在运行时是根据执行环境绑定的，主要分为以下六种情况：&lt;br&gt;当包含this的函数：&lt;br&gt;1.作为普通的全局函数调用：在全局函数中，this指向window。&lt;br&gt;2.作为对象的方法调用：在函数被作为某个对象的方法调用时，this指向那个对象。&lt;br&gt;3.作为构造函数调用：当函数为构造函数，此时this指向实例出来的对象。&lt;br&gt;4.被apply,bind，call等改变执行环境时，this指向其他对象。&lt;br&gt;5.是匿名函数，this永远指向window（在不改变执行环境的情况下）。&lt;br&gt;6.其他情况。&lt;/p&gt;
&lt;p&gt;注意：无论那种情况，this的指向都遵循着根据执行环境绑定的规律。&lt;br&gt;下面进行详细说明：&lt;/p&gt;
&lt;h2 id=&quot;一、作为普通全局函数调用&quot;&gt;&lt;a href=&quot;#一、作为普通全局函数调用&quot; class=&quot;headerlink&quot; title=&quot;一、作为普通全局函数调用&quot;&gt;&lt;/a&gt;一、作为普通全局函数调用&lt;/h2&gt;&lt;p&gt;看一个栗子。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var name=&lt;span class=&quot;string&quot;&gt;&#39;w&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	console.log(this.name);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a();//&lt;span class=&quot;string&quot;&gt;&#39;w&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此时，函数a作为普通的全局函数调用，形式为函数名加括号，这种调用方法最常见，在这里，函数a中this指向window。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript学习" scheme="http://yoursite.com/tags/JavaScript%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JS闭包及应用</title>
    <link href="http://yoursite.com/2017/02/28/js%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2017/02/28/js闭包/</id>
    <published>2017-02-28T13:11:08.000Z</published>
    <updated>2017-05-15T06:44:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>定义：闭包是有权访问另一函数作用域的变量的函数。<br>常见创建闭包的方式：在一个函数内部创建另一个函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">str</span>)</span>&#123;</div><div class="line"> <span class="keyword">var</span> hello = <span class="string">"hello"</span>;</div><div class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(hello+str);</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="理解执行环境和作用域链"><a href="#理解执行环境和作用域链" class="headerlink" title="理解执行环境和作用域链"></a>理解执行环境和作用域链</h2><h3 id="执行环境（execution-context）"><a href="#执行环境（execution-context）" class="headerlink" title="执行环境（execution context）"></a>执行环境（execution context）</h3><p>1.<strong>执行环境</strong>：定义了变量或函数有权访问的其他数据。<br>2.<strong>变量对象</strong>：每个执行环境都有一个与之关联的变量对象（variable object）,环境中定义的所有变量和函数都保存在这个对象里。<br>3.某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。<br>4.<strong>全局执行环境</strong>:全局执行环境是最外围的一个执行环境，根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是window对象。全局执行环境直到应用程序退出才会被销毁。<br>5.<strong>每个函数都有自己的执行环境</strong>：当执行流进入到一个函数时，函数的环境就会被推入一个<strong>环境栈</strong>中，在函数执行之后，栈将环境弹出，把控制权返回给之前的执行环境。</p>
<h3 id="作用域链（scope-chain）"><a href="#作用域链（scope-chain）" class="headerlink" title="作用域链（scope chain）"></a>作用域链（scope chain）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>当代码在一个环境中执行时，会创建变量对象的一个作用域链。<br>作用域链保证对执行环境有权访问的所有变量和函数的有序访问。 </p>
</blockquote>
<p><strong>内容</strong>：作用域链的前端，始终是当前执行代码所在环境的变量对象。（如果环境是函数，则其活动对象为变量对象，活动对象最开始只包含一个变量，即arguments对象）。下一个变量对象来自外部环境，下一个变量对象来自于下一个包含环境。全局执行环境的变量对象始终都是作用域链中最后一个对象。</p>
<h4 id="作用域链的创建"><a href="#作用域链的创建" class="headerlink" title="作用域链的创建"></a>作用域链的创建</h4><p>当创建函数时:  [[scope]]属性保存包含全局变量的作用域链；<br>当调用函数时:  创建函数执行环境（execution context）;复制[[scope]]中对象构建执行环境的作用域链；活动对象（activation object）被创建并被推入执行环境作用域链前端;<br><strong>例</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">str</span>)</span>&#123;</div><div class="line"> <span class="keyword">var</span> hello = <span class="string">"hello"</span>;</div><div class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(hello+str);</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当创建sayHi()函数时:  [[scope]]属性保存包含全局变量对象（包含sayHi()函数）的作用域链。<br>当调用sayHi()函数时:  创建sayHi()函数的执行环境;复制[[scope]]中对象构建执行环境的作用域链；包含arguments,str和hello的活动对象被创建并被推入执行环境作用域链前端； </p>
<h4 id="作用域链的销毁"><a href="#作用域链的销毁" class="headerlink" title="作用域链的销毁"></a>作用域链的销毁</h4><p><strong>一般情况下</strong>：当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域。<br><strong>有闭包的情况</strong>：在外部函数,如sayHi()函数，执行完毕后，其包含arguments，str和hello的活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。使用将sayHi设置为null的方法解除对该函数的引用，即通知垃圾回收例程将其清除，匿名函数作用域被销毁。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">str</span>)</span>&#123;</div><div class="line"> <span class="keyword">var</span> hello = <span class="string">"hello"</span>;</div><div class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(hello+str);</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line">sayHi=<span class="literal">null</span>;</div></pre></td></tr></table></figure></p>
<h4 id="作用域链本质"><a href="#作用域链本质" class="headerlink" title="作用域链本质"></a>作用域链本质</h4><p>作用域链的本质是指向变量对象的<strong>指针列表</strong>，只<strong>引用</strong>，但不实际包含变量对象。</p>
<h4 id="分析调用sayHi（）函数过程中的作用域链"><a href="#分析调用sayHi（）函数过程中的作用域链" class="headerlink" title="分析调用sayHi（）函数过程中的作用域链"></a>分析调用sayHi（）函数过程中的作用域链</h4><p>闭包的作用域链包含它自己的作用域，包含函数的作用域和全局作用域。<br><img src="http://ww1.sinaimg.cn/mw1024/006bAzaMjw1falvb7a9u8j30mr0csdhd.jpg" alt=""></p>
<h2 id="关于闭包值得注意的问题"><a href="#关于闭包值得注意的问题" class="headerlink" title="关于闭包值得注意的问题"></a>关于闭包值得注意的问题</h2><h3 id="1-闭包只能取得包含函数中任何变量的最后一个值"><a href="#1-闭包只能取得包含函数中任何变量的最后一个值" class="headerlink" title="1.闭包只能取得包含函数中任何变量的最后一个值"></a>1.闭包只能取得包含函数中任何变量的最后一个值</h3><h3 id="2-当闭包为匿名函数，this对象通常指向window，除非通过apply-或call-改变函数执行环境。"><a href="#2-当闭包为匿名函数，this对象通常指向window，除非通过apply-或call-改变函数执行环境。" class="headerlink" title="2.当闭包为匿名函数，this对象通常指向window，除非通过apply()或call()改变函数执行环境。"></a>2.当闭包为匿名函数，this对象通常指向window，除非通过apply()或call()改变函数执行环境。</h3><p><strong>原因</strong>：每个函数在被调用时都会自动取得两个特殊的变量：<strong>this</strong>和<strong>arguments</strong>，因此当内部函数在搜索这两个变量时，只会搜索到其活动对象为止。而匿名函数的this指向window。<br><strong>访问外部作用域中this对象的方法</strong>：把外部作用域中的this对象保存在闭包能够访问的变量里。<br>修改前：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"><span class="keyword">var</span> object=&#123;</div><div class="line">	<span class="attr">name</span> : <span class="string">"My Object"</span>;</div><div class="line">	getNameFunc:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name;<span class="comment">//"The Window"</span></div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>修改后：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"><span class="keyword">var</span> object=&#123;</div><div class="line">	<span class="attr">name</span> : <span class="string">"My Object"</span>;</div><div class="line">	getNameFunc:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> that.name;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">alert(object.getNameFunc()())；<span class="comment">//"My Object"</span></div></pre></td></tr></table></figure></p>
<p><strong>访问外部作用域中arguments对象的方法</strong>：同样需要把该对象保存在闭包能够访问的变量里。<br><strong>另外，关于this对象</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"Window"</span>;</div><div class="line"><span class="keyword">var</span> object=&#123;</div><div class="line">	<span class="attr">name</span> : <span class="string">"My Object"</span>;</div><div class="line">	getName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">(object.getName=object.getName)()；<span class="comment">//"My Object"</span></div></pre></td></tr></table></figure></p>
<p>上例中先执行赋值语句，在调用赋值后的结果，因为此赋值表达式的值是<strong>函数本身</strong>，所以this的值不能维持。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="1-闭包会比其他函数占用更多内存。"><a href="#1-闭包会比其他函数占用更多内存。" class="headerlink" title="1.闭包会比其他函数占用更多内存。"></a>1.闭包会比其他函数占用更多内存。</h3><h3 id="2-当函数返回了一个闭包，这个函数的作用域将会在内存中保存至闭包不存在为止。"><a href="#2-当函数返回了一个闭包，这个函数的作用域将会在内存中保存至闭包不存在为止。" class="headerlink" title="2.当函数返回了一个闭包，这个函数的作用域将会在内存中保存至闭包不存在为止。"></a>2.当函数返回了一个闭包，这个函数的作用域将会在内存中保存至闭包不存在为止。</h3><p>解决：将外部函数设置为null。  </p>
<h3 id="3-如果闭包的作用域链中保存着HTML元素，意味着该元素将无法被销毁。"><a href="#3-如果闭包的作用域链中保存着HTML元素，意味着该元素将无法被销毁。" class="headerlink" title="3.如果闭包的作用域链中保存着HTML元素，意味着该元素将无法被销毁。"></a>3.如果闭包的作用域链中保存着HTML元素，意味着该元素将无法被销毁。</h3><p>解决：将HTML元素保存在外部作用域中，并在不需要时将保存HTML元素的变量设置为null。</p>
<h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><h3 id="闭包模仿块级作用域"><a href="#闭包模仿块级作用域" class="headerlink" title="闭包模仿块级作用域"></a>闭包模仿块级作用域</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><strong>创建并立即调用</strong>一个函数;<br>修改前：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>)</span></div><div class="line">	<span class="title">for</span>(<span class="params">var i=<span class="number">0</span>;i&lt;count;i++</span>)&#123;</div><div class="line">		alert(i);</div><div class="line">	&#125;</div><div class="line">	alert(i)；<span class="comment">//计数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里首先创建了一个outputNumbers（）函数，在函数内有一个for循环，由于JavaScript没有块级作用域，所以即使在循环外也可以访问循环内的变量i。</p>
</blockquote>
<p>修改后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>)</span></div><div class="line">	(<span class="params">function(</span>)&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</div><div class="line">			alert(i);</div><div class="line">		&#125;</div><div class="line">	&#125;)();</div><div class="line">	alert(i)<span class="comment">//导致一个错误！</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>现在在for循环外创建了一个私有作用域，并产生了一个闭包，由于在匿名函数中定义的任何变量都会在执行结束后销毁，因此变量i只能在循环中使用。</p>
</blockquote>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>经常<strong>在全局作用域中被用在函数外部</strong>，限制向全局作用域中添加过多变量和函数。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>既可以执行其中的代码，又不会在内存中留下对该函数的引用；<br>函数内部的所有变量都会被立即销毁（除非将某些变量赋值给了外部作用域）；<br>通过创建私有作用域，每个开发人员既可以使用自己的变量，又不并担心搞乱全局作用域；<br>减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁作用域链了；</p>
<h3 id="闭包创建私有变量"><a href="#闭包创建私有变量" class="headerlink" title="闭包创建私有变量"></a>闭包创建私有变量</h3><p>任何在函数中定义的变量都可以认为是私有变量。<br>私有变量包括函数的参数、局部变量和在函数内部定义的其它函数。<br>访问私有变量和私有函数的公有方法被称为<strong>特权方法</strong>（privileged method）。</p>
<h4 id="方法一：在构造函数中定义特权方法"><a href="#方法一：在构造函数中定义特权方法" class="headerlink" title="方法一：在构造函数中定义特权方法"></a>方法一：在构造函数中定义特权方法</h4><p>在构造函数内部定义了所有私有变量和函数，然后创建能访问这些私有成员的特权方法。<br>利用私有和特权成员可以<strong>隐藏</strong>那些不应该被直接修改的数据。<br>例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">MyObject</span></span>()&#123;</div><div class="line">	var privateVariable = 10;</div><div class="line">	<span class="keyword">function</span> <span class="function"><span class="title">privarFunc</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> <span class="literal">false</span>;	</div><div class="line">	&#125;</div><div class="line">	this.publicMethod = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">		privateVariable++；</div><div class="line">		<span class="built_in">return</span> privarFunc();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造函数模式的缺点：每个实例都会创建同样一组新方法。静态私有变量来实现特权方法可以避免这个问题。</p>
<h4 id="方法二：静态私有变量"><a href="#方法二：静态私有变量" class="headerlink" title="方法二：静态私有变量"></a>方法二：静态私有变量</h4><p>这个模式创建一个私有作用域，并在其中封装一个构造函数及相应的方法。<br>例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">（<span class="keyword">function</span>（）&#123;</div><div class="line">	var privateVariable = 10;</div><div class="line">	<span class="keyword">function</span> <span class="function"><span class="title">privarFunc</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> <span class="literal">false</span>;	</div><div class="line">	&#125;</div><div class="line">	MyObject = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">	&#125;//全局变量</div><div class="line">	MyObject.prototype.publicMethod = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">		privateVariable++；</div><div class="line">		<span class="built_in">return</span> privarFunc();	</div><div class="line">	&#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>缺点：每个实例都没有自己的私有变量。</p>
<h4 id="方法三：模块模式（module-pattern）"><a href="#方法三：模块模式（module-pattern）" class="headerlink" title="方法三：模块模式（module pattern）"></a>方法三：模块模式（module pattern）</h4><p>为<strong>单例</strong>创建私有变量和特权方法。<br>模块模式使用一个<strong>返回对象的匿名函数</strong>，这个匿名函数内部首先定义了私有变量和函数，然后将一个对象字面量作为函数的值返回。<br>例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var singleton =<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">	var privateVariable = 10;</div><div class="line">	<span class="keyword">function</span> <span class="function"><span class="title">privarFunc</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> <span class="literal">false</span>;	</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">return</span>&#123;</div><div class="line">		publicProperty : <span class="literal">true</span>;</div><div class="line">		publicMethod :　<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">			privateVariable++；</div><div class="line">			<span class="built_in">return</span> privarFunc();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<h4 id="方法四：增强的模块模式"><a href="#方法四：增强的模块模式" class="headerlink" title="方法四：增强的模块模式"></a>方法四：增强的模块模式</h4><p>适合单例必须是<strong>某种类型的实例</strong>，同时还必须添加某些属性和（或）方法对其<strong>加以增强</strong>的情况。<br>创建一个匿名函数，定义私有变量和方法，创建一个对象实例，为实例添加特权方法，最后返回这个实例。<br>例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var singleton = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">	var privateVariable = 10;</div><div class="line">	<span class="keyword">function</span> <span class="function"><span class="title">privarFunc</span></span>()&#123;</div><div class="line">		<span class="built_in">return</span> <span class="literal">false</span>;	</div><div class="line">	&#125;</div><div class="line">    var object = new CustonType();</div><div class="line">	object.publicProperty = <span class="literal">true</span>;</div><div class="line">	object.publicMethod = <span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">		privateVariable++；</div><div class="line">		<span class="built_in">return</span> privarFunc();	</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">return</span> object; </div><div class="line">&#125;()；</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;定义：闭包是有权访问另一函数作用域的变量的函数。&lt;br&gt;常见创建闭包的方式：在一个函数内部创建另一个函数。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayHi&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;str&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; hello = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        alert(hello+str);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript学习" scheme="http://yoursite.com/tags/JavaScript%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>制作下拉菜单Tips&amp;相关知识点复习</title>
    <link href="http://yoursite.com/2017/02/28/%E5%88%B6%E4%BD%9C%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95Tips/"/>
    <id>http://yoursite.com/2017/02/28/制作下拉菜单Tips/</id>
    <published>2017-02-28T13:11:08.000Z</published>
    <updated>2017-05-08T03:40:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="制作多级菜单"><a href="#制作多级菜单" class="headerlink" title="制作多级菜单"></a>制作多级菜单</h2><p>在第一层<code>&lt;li&gt;</code>标签下添加<code>&lt;ul&gt;</code>标签，创建二级菜单，在第二层<code>&lt;li&gt;</code>标签下添加<code>&lt;ul&gt;</code>标签，创建三级菜单…以此类推。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">   &lt;ul class=<span class="string">"top_nav"</span>&gt;          </div><div class="line">	&lt;li&gt;&lt;a href=<span class="string">"#"</span>&gt;课程大厅&lt;/a&gt; &lt;!--一级菜单--&gt;</div><div class="line">		&lt;ul&gt;                  </div><div class="line">			&lt;li&gt;&lt;a href=<span class="string">"#"</span>&gt;前端课程&lt;/a&gt; &lt;!--二级菜单--&gt;</div><div class="line">				&lt;ul&gt;          </div><div class="line">					&lt;li&gt;&lt;a href=<span class="string">"#"</span>&gt;html&lt;/a&gt;&lt;/li&gt; &lt;!--三级菜单--&gt;</div><div class="line">					&lt;li&gt;&lt;a href=<span class="string">"#"</span>&gt;css&lt;/a&gt;&lt;/li&gt;</div><div class="line">					&lt;li&gt;&lt;a href=<span class="string">"#"</span>&gt;javascript&lt;/a&gt;&lt;/li&gt;</div><div class="line">				&lt;/ul&gt;</div><div class="line">			&lt;/li&gt;</div><div class="line">		&lt;/ul&gt;</div><div class="line">	&lt;/li&gt;</div><div class="line">	&lt;li&gt;&lt;a href=<span class="string">"#"</span>&gt;学习中心&lt;/a&gt;&lt;/li&gt;</div><div class="line">	&lt;li&gt;&lt;a href=<span class="string">"#"</span>&gt;关于我们&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>对所有li元素设置position：relative，对li元素下的子元素ul设置position：absolute，使下一级菜单相对于上一级菜单定位。<br><a id="more"></a></p>
<h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><p>鼠标停留在菜单上，以某种动画效果显示下一级菜单；鼠标离开，下一级菜单隐藏。</p>
<h3 id="JavaScript实现"><a href="#JavaScript实现" class="headerlink" title="JavaScript实现"></a>JavaScript实现</h3><blockquote>
<p>思路：<br>Step1:遍历所有<code>&lt;li&gt;</code>标签，为所有的li添加onmouseover和onmouseout事件；<br>Step2:如果此li下包含子元素ul（非孙辈），则把该子元素ul和指定属性的目标值作为参数传入move函数；<br>Step3:move函数：为传入的ul绑定定时器，设定速度（注意小数点），在指定属性现值不等于目标值的情况下，指定属性值为现值加速度，否则清除定时器。  为避免鼠标移动过快出现多个定时器，在move函数开头也需清除定时器；<br>Step4:获取html元素的属性值需要编写getStyle()函数； </p>
</blockquote>
<h3 id="jquery实现"><a href="#jquery实现" class="headerlink" title="jquery实现"></a>jquery实现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(document).ready(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">$(<span class="string">'li'</span>).has(<span class="string">'ul'</span>).mouseover(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">$(this).children(<span class="string">'ul'</span>).css(<span class="string">'display'</span>,<span class="string">'block'</span>)&#125;).mouseout(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">$(this).children(<span class="string">'ul'</span>).css(<span class="string">'display'</span>,<span class="string">'none'</span>);</div><div class="line">&#125;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="CSS3实现"><a href="#CSS3实现" class="headerlink" title="CSS3实现"></a>CSS3实现</h3><blockquote>
<p>思路：使用transition属性实现;  </p>
</blockquote>
<h4 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h4><p><strong>Transition:</strong><br>用于在一定的时间内平滑的过渡，可以在鼠标点击，获取焦点，被点击或对元素任何改变中触发，并以圆滑的动画效果改变css属性的属性值。<br><strong>取值：</strong><br>&lt;’ transition-property ‘&gt;： 检索或设置对象中的参与过渡的属性<br>&lt;’ transition-duration ‘&gt;： 检索或设置对象过渡的持续时间<br>&lt;’ transition-timing-function ‘&gt;： 检索或设置对象中过渡的动画类型<br>&lt;’ transition-delay ‘&gt;： 检索或设置对象延迟过渡的时间<br><strong>eg:</strong><br>Transition-property: border-color, background-color, color<br>Transition-duration:.2s<br>Transition-timing-function:ease-in<br>Transition-delay:.1s<br>或<br>Transition:all,.2s,ease-in<br><em>设置transition属性后，需hover，focus等触发。</em><br><strong>兼容：</strong><br>IE10.0+, Firefox4.0-15.0(-moz-) 16.0+, Chrome4.0-25.0(-webkit-) 26+, Safari6.0(-webkit-) 6.1+, Opera15.0+</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;制作多级菜单&quot;&gt;&lt;a href=&quot;#制作多级菜单&quot; class=&quot;headerlink&quot; title=&quot;制作多级菜单&quot;&gt;&lt;/a&gt;制作多级菜单&lt;/h2&gt;&lt;p&gt;在第一层&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;标签下添加&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;标签，创建二级菜单，在第二层&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;标签下添加&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;标签，创建三级菜单…以此类推。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;   &amp;lt;ul class=&lt;span class=&quot;string&quot;&gt;&quot;top_nav&quot;&lt;/span&gt;&amp;gt;          &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;&amp;gt;课程大厅&amp;lt;/a&amp;gt; &amp;lt;!--一级菜单--&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;lt;ul&amp;gt;                  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;&amp;gt;前端课程&amp;lt;/a&amp;gt; &amp;lt;!--二级菜单--&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				&amp;lt;ul&amp;gt;          &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;&amp;gt;html&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;!--三级菜单--&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;&amp;gt;css&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;					&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;&amp;gt;javascript&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;				&amp;lt;/ul&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;lt;/ul&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;&amp;gt;学习中心&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;li&amp;gt;&amp;lt;a href=&lt;span class=&quot;string&quot;&gt;&quot;#&quot;&lt;/span&gt;&amp;gt;关于我们&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对所有li元素设置position：relative，对li元素下的子元素ul设置position：absolute，使下一级菜单相对于上一级菜单定位。&lt;br&gt;
    
    </summary>
    
    
      <category term="技巧" scheme="http://yoursite.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
</feed>
